#set title 'fmoe:fragmentation';

function GetBasedir;
function RenderTemplate;
function BatchBinarySearch;
function GetProgramBasisSets;
function GetNumberOfFunctions;
function GetFragmentationPanel;
function AbinitMpFilePrompt;
function GetTemplates;
global FMOE_BASISSET_DATA;
global fmoe_templates;


local function DetachMarker [color, bonds]
    // detach marker options
    // :color: coloar
    // :bonds: List[(atom, atom)]
    // TODO: move to View
    local bda = first tr bonds;
    local baa = second tr bonds;

    local pos_bda = tr aPos bda;
    local pos_baa = tr aPos baa;
    local diff = pos_baa - pos_bda;

    local cap_center = pos_bda + 0.4 * diff;
    local cap_head = pos_bda + 0.2 * diff;
    local cap_axis = cap_head - cap_center;
    local sphere_center = pos_bda + 0.6 * diff;

    return apt G_Cat [
        apt G_Cap [color, cap_center, cap_axis, 0.8, 2],
        apt G_Sphere [color, sphere_center, 0.2, 2]
    ];
endfunction


local function DrawDetachMarker [title_prefix, color, bonds]
    // :title_prefix: 
    // :color:
    // :bonds: List[(atom, atom)]
    // TODO: move to view
    local keys = app GCreate tok_cat [title_prefix, totok igen length bonds];
    app GVertex apt cat [keys, DetachMarker [color, bonds]];
    return keys;
endfunction


local function FMOFragmentationProtein chains
    // divides protetins into fragments
    // :chains:
    // return: List[(atom, atom)]
    chains = chains | app andE (rType cResidues chains == 'amino');
    local atoms = rAtoms (cat cResidues chains);
    local bda = apt mget [atoms, aName atoms == 'CA'];
    local baa = apt mget [atoms, aName atoms == 'C'];
    return tr [bda, baa] | app andE tr [app length bda, app length baa];
endfunction


local function IsCTerminalFragment fragments
    // :fragments:
    // return index of fragments
    local is_amino = app andE eqE [rType aResidue fragments, ['amino']];
    local coo = andE [
      eqE [app add eqE [aMMType fragments, 'O2'], 2],
      eqE [app add eqE [aMMType fragments, 'C'], 1],
      eqE [app length fragments, 3]
    ];
    local cooh = andE [
      eqE [app add eqE [aMMType fragments, 'O'], 1],
      eqE [app add eqE [aMMType fragments, 'C'], 1],
      eqE [app add eqE [aMMType fragments, 'OH'], 1],
      eqE [app add eqE [aMMType fragments, 'HO'], 1],
      eqE [app length fragments, 4]
    ];

    return andE [is_amino, orE[coo, cooh]];
endfunction


local function StripBondExtra bonds
    // ?
    local bda = app first bonds;
    local baa = app second bonds;
    return tr [bda, baa];
endfunction


global function PartitionAtoms [atoms, bonds]
    local satoms = sort atoms;
    local nbr = BondGraph satoms;
    local [bda, baa] = tr StripBondExtra bonds;
    local ibonds = tr [BatchBinarySearch [bda, satoms], BatchBinarySearch [baa, satoms]];
    ibonds = ibonds | app andE neE [ibonds, 0];
    nbr = graph_ecutE [nbr, tr ibonds];
    local unsorted = apt get [[satoms], graph_ccomponent_list nbr];
    return unsorted[x_sort app min aNumber unsorted];
endfunction


global function FMOFragmentation chains
    local bonds = FMOFragmentationProtein chains;
    local frags = PartitionAtoms [cat cAtoms chains, bonds];
    local terms = cat (frags | IsCTerminalFragment frags);
    local mask = not app orE app cat apt eqE [bonds, [[terms]]];
    return bonds | mask;
endfunction


local function FormatDetachedBonds bonds
    // :bonds:
    // return: 
    // TODO: move to model
    local bda = first tr bonds;
    local baa = second tr bonds;
    local types = third tr bonds;
    return apt twrite [
        '{}\t{}\t{}{} {}\t{}{} {}',
        igen length bonds, types,
        rName aResidue bda, rUID aResidue bda, aName bda,
        rName aResidue baa, rUID aResidue baa, aName baa
    ];
endfunction


local function appOrE v
    return app orE v;
endfunction


local function Common t
    // ?
    if t === [] then
        return [];
    endif
    if isflat t then
        t = [t];
    endif
    local cand = app uniq t;
    local freq = apt freq [cand, t];
    return apt get [cand, app x_max freq];
endfunction


local function FormatFragments [basisset, fragments, detached, attached]
    // :basisset: 
    // :fragments: List[List[atom]]
    // :detached: List[atom]
    // :attached: List[atom]
    local res = Common rName aResidue fragments;
    local resi = totok Common rUID aResidue fragments;
    local nD = app length detached;
    local nA = app length attached;

    return apt twrite [
        '{}\t{}\t{}\t{}\t{}\t{}\t{}',
        igen length fragments, apt tok_cat [res, resi], app length fragments,
        GetNumberOfFunctions [basisset, apt cat [fragments, attached]],
        nD, nA, app add aFCharge fragments + nD - nA
    ];
endfunction


local function RemoveAllBonds detached_bonds
    GDestroy (tr *detached_bonds)(4);
    *detached_bonds = [];
endfunction


local function RemoveAutoBonds detached_bonds
    local bonds = *detached_bonds;
    local mask = third tr bonds == 'A';
    GDestroy (tr (bonds | mask))(4);
    *detached_bonds = bonds | not mask;
endfunction


local function RemoveBondsByIndices [detached_bonds, indices]
    local bonds = *detached_bonds;
    local mask = zero igen length bonds;
    mask[indices] = 1;
    GDestroy (tr (bonds | mask))(4);
    *detached_bonds = bonds | not mask;
endfunction


local function AutoSplitBonds [detached_bonds, chains]
    local raw_bonds = FMOFragmentation chains;
    *detached_bonds = cat [
        *detached_bonds,
        apt cat [raw_bonds, 'A', DrawDetachMarker [first cTag chains, 0xffffff, raw_bonds]]
    ];
endfunction


local function AddSplitBond [detached_bonds, [bda, baa]]
    *detached_bonds = cat [
        *detached_bonds,
        [[bda, baa, 'M', DrawDetachMarker [cTag aChain bda, 0x00ffff, [[bda, baa]]]]]
    ];
endfunction


local function UpdateFragments [fragments, atoms, detached_bonds]
    *fragments = PartitionAtoms [atoms, detached_bonds];
endfunction


local function AssignAtomsToFragments [atoms, fragments]
    local result, i;
    for i = 1, length fragments loop
        result(i) = atoms | app add apt eqE [[fragments(i)], atoms];
    endloop
    return result;
endfunction


local function mergeFragments [fragments, merge_list]
    // merge_list element should be sorted.
    // print fragments;
    local data = [];
    local i, j;
    local map = igen length fragments;

    for i = 1, length merge_list loop
        for j = 2, length merge_list(i) loop
            map[merge_list(i)(j)] = merge_list(i)(1);
        endloop
    endloop

    for i = 1, length map loop
        data = tagpoke [data, totok map(i) , cat [tagpeek [data, totok map(i)], fragments(i)]];
    endloop
    return tagvals data;
endfunction


local function formatMergeList merge_list
    // :bonds:
    // return: 
    // TODO: check duplicate
    local data = [];
    local i, j;
    for i = 1, length merge_list loop
        for j = 1, length merge_list(i) loop
            data = cat [data, [[i, merge_list(i)(j)]]];
        endloop
    endloop
    return apt twrite [
        '{}\t{}\t{}',
        igen length first tr data,
        first tr data,
        second tr data
    ];
endfunction


local function RefreshWindow [wkey, basisset, detached_bonds, fragments, opts]
    opts = tagcat [opts, [
        merge: 0,
        merge_list: [],
        merged_fragments: []
    ]];
    local [bda, baa] = tr StripBondExtra detached_bonds;
    local detached_bond_list = FormatDetachedBonds detached_bonds;
    local fragment_list = FormatFragments [basisset, fragments,
        AssignAtomsToFragments [bda, fragments],
        AssignAtomsToFragments [baa, fragments]];
    
    if opts.merge then
        WindowSetAttr [wkey, [
            detached_bond_list: [text: detached_bond_list],
            fragment_list: [text: fragment_list],
            merge_list: [text: formatMergeList opts.merge_list],
            merged_fragment_list: [text: FormatFragments [basisset, opts.merged_fragments,
                AssignAtomsToFragments [bda, opts.merged_fragments],
                AssignAtomsToFragments [baa, opts.merged_fragments]]
            ]
        ]];
    else
        WindowSetAttr [wkey, [
            detached_bond_list: [text: detached_bond_list],
            fragment_list: [text: fragment_list]
        ]];
    endif
endfunction


const BOND_PICKER_PANEL = [
    name: 'atom',
    mode: 'pickAtom',
    title: 'pick BDA...',
    location: 'MOE'
];


local function CleanupBondPicker [quit, dbda, dcands]
    dvar_lock app dvar_open [quit, dbda, dcands];
    local bda = *dbda;
    if not (bda === []) then
        local [atom, colorby, color] = bda;
        aSetColorBy [atom, colorby];
        aSetRGB [atom, color];
    endif
    local cands = *dcands;
    if not (cands === []) then
        local [nbr, look] = cands;
        apt aSetNucleusLook [nbr, look];
    endif
endfunction


local function FilterCandidates [bda, nbr]
    if aGeometry bda === 'sp3' then
        return nbr | aElement nbr <> 'H';
    else
        return nbr | andE [aGeometry nbr == 'sp3', aElement nbr == 'C'];
    endif
endfunction


local function BondPickerTask []
    local quit = dvar_open [];
    dvar_lock quit;
    local dbda = dvar_open [];
    local dcands = dvar_open [];

    task_call [#CleanupBondPicker, [quit, dbda, dcands], [master: 'none', creator: 'detach']];

    local wkey = WindowCreate BOND_PICKER_PANEL;
    local bda = (first WindowWait wkey).atom;
    *dbda = [bda, aColorBy bda, aRGB bda];
    aSetColorBy [bda, 'rgb'];
    aSetRGB [bda, 0x999900];

    local nbr = cat aBonds bda;
    local candidates = FilterCandidates [bda, nbr];
    *dcands = [candidates, aNucleusLook candidates];
    aSetNucleusLook [candidates, 'small-sphere'];

    WindowSetAttr [wkey, [atom: [title: 'pick BAA...']]];

    local baa;
    loop
        baa = (first WindowWait wkey).atom;
        if orE eqE [baa, candidates] then
            break;
        elseif orE eqE [baa, nbr] then
            if YesNo 'Selected atom is not SP3 carbon.\ncontinue?' then
                break;
            endif
        endif
    endloop

    WindowDestroy wkey;
    dvar_unlock quit;
    return [bda, baa];
endfunction


local function BondPicker []
    local [result, status] = task_call [#BondPickerTask, [], [master: 'parent', creator: 'blockEOK']];
    if status === '' then
        return result;
    endif
endfunction


local function CleanupMain [quit, wkey, detached_bonds]
    dvar_lock app dvar_open [quit, detached_bonds];
    GDestroy (tr *detached_bonds)(4);
    WindowDestroy wkey;
endfunction


local function Sentinel [wkey, detached_bonds, fragments]
    local old_selected = [];
    local i = 0;
    local [bda, baa, _, gobj] = tr * detached_bonds;
    while andE [andE oValid bda, andE oValid baa, andE GKey gobj] loop
        local rbda = andE [rRibbonMode aResidue bda <> 'none', rRibbonEnable aResidue bda];
        local rbaa = andE [rRibbonMode aResidue baa <> 'none', rRibbonEnable aResidue baa];
        GSetVisible [gobj, apt orE [rbda, not aHidden bda, rbaa, not aHidden baa]];

        local selected = SelectedAtoms [];
        if not (old_selected === selected) then
            old_selected = selected;

            WindowSetData [wkey, [
                fragment_list: (igen length *fragments) | app length AssignAtomsToFragments [selected, *fragments]
            ]];
        endif

        sleep 0.2;
        [bda, baa, _, gobj] = tr *detached_bonds;
    endloop
    task_kill (task_info task_key -1).parent;
endfunction


local function CheckAtomNames atoms
    // TODO: make test
    atoms = atoms | rType aResidue atoms == 'none';

    local alert = [];
    local atom;
    for atom in atoms loop
        local element = aElement atom;
        local name = tolower string aName atom;
        if length name < 2 then
            continue;
        endif
        if andE [element === 'H', orE (name(2) == "eofgs")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'B', orE (name(2) == "eraikh")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'C', orE (name(2) == "laroudsemfn")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'N', orE (name(2) == "eaibdpoh")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'O', orE (name(2) == "sg")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'F', orE (name(2) == "erml")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'P', orE (name(2) == "drmtboau")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'S', orE (name(2) == "icernbmg")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'K', orE (name(2) == "r")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'Y', orE (name(2) == "b")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'I', orE (name(2) == "nr")] then
            alert = append [alert, atom];
        endif
        if andE [element === 'U', orE (name(2) == "u")] then
            alert = append [alert, atom];
        endif
    endloop
    return alert;
endfunction


const ALERT_ATOM_PANEL = [
    name: 'atom_alert',
    title: 'Atom name alert',
    windowName: 'atom_alert',
    text: ['Auto', 'Continue', 'Cancel'],
    Label: [text: 'these atoms may misrecognition by ABINIT-MP.\nIt is recommended to rename atom name(s).'],
    Hbox: [
        Listbox: [name: 'atoms', onTrigger: 'return', type: 'int'],
        Button: [text: 'refresh', name: 'refresh']
    ]
];


local function AlertAtomDialog atoms
    local wkey = WindowCreate ALERT_ATOM_PANEL;
    WindowShow wkey;

    local alerts = CheckAtomNames atoms;
    if alerts === [] then
        return [1, []];
    endif

    WindowSetAttr [wkey, [atoms: [text: aName alerts]]];

    loop
        local [values, trigger] = WindowWait wkey;
        if trigger === 'atoms' then
            if values.atoms(2) == 1 then
                aSetSelected [Atoms [], 0];
                aSetSelected [alerts(values.atoms(1)), 1];
            else
                View alerts(values.atoms(1));
            endif

        elseif trigger === 'refresh' then
            alerts = CheckAtomNames atoms;
            if alerts === [] then
                return [1, []];
            endif
            WindowSetAttr [wkey, [atoms: [text: aName alerts]]];

        elseif trigger === 'atom_alert' then
            if values.atom_alert === 'Auto' then
                alerts = CheckAtomNames atoms;
                aSetName [alerts, app token apt poke [app string aName alerts, 2, "X"]];
                return [1, []];
            elseif values.atom_alert === 'Continue' then
                return [1, alerts];
            elseif values.atom_alert === 'Cancel' then
                return [0, alerts];
            endif

        endif
    endloop

    WindowDestroy wkey;
endfunction


local function FormatAtomName [atom]
    if tok_length aElement atom == 1 then
        return tok_cat [' ', aName atom];
    else
        return aName atom;
    endif
endfunction


global function fwrite_abinitmp_pdb_line [f, i, atom]
    local header = 'ATOM  ';
    if app orE apt eqE [rType aResidue atom, [['heme', 'none']]] then
        header = 'HETATM';
    endif
    local residue = aResidue atom;
    local [x, y, z] = aPos atom;

	// '{t:-6}{n:5} {t:-4}{c:1}{t:3} {c:1}{n:4}{c:1}   ',
	// '{n:8.3f}{n:8.3f}{n:8.3f}', occupancy_fmt, tfactor_fmt,
	// '          {t:2}{t:2}\n'
    fwrite [f, '{t:-6}{n:5} {t:-4} {t:3} {c:1}{n:4}{c:1}   {n:8.3f}{n:8.3f}{n:8.3f}{n:6.2f}{n:6.2f}\n', header,
        i,
        FormatAtomName atom,
        rName residue,
        cLetter aChain atom,
        rUID residue,
        rINS residue,
        x, y, z,
        aOccupancy atom,
        aTempFactor atom
    ];
endfunction


global function fwrite_abinitmp_pdb [f, chains]
    local chain, atom;
    local i = 0;
    local c = 0;
    local indices = [];
    for chain in chains loop
        c = c + 1;
        for atom in cat cAtoms chain loop
            i = i + 1;
            indices(i) = atom;

            fwrite_abinitmp_pdb_line [f, i, atom];
        endloop
        if c == length chains then
            fwrite [f, 'END\n'];
        else
            fwrite [f, 'TER\n'];
        endif
    endloop
    return indices;
endfunction


local function AbinitMpFragmentFormat l
    local result = [];
    while length l >= 10 loop
        result = append [result, tok_cat apt twrite ['{n:8}', keep [l, 10]]];
        l = drop [l, 10];
    endloop
    if length l <> 0 then
        result = append [result, tok_cat apt twrite ['{n:8}', l]];
    endif
    return tok_cat droplast cat tr [result, '\n'];
endfunction


local function FormatAbinitMpFragment [atoms, fragments, detached_bonds]
    local [bda, baa] = tr StripBondExtra detached_bonds;
    local detached = AssignAtomsToFragments [bda, fragments];
    local attached = AssignAtomsToFragments [baa, fragments];
    local atom_indices = app sort apt indexof [fragments, [atoms]];

    local rbaa = cat attached | cat (attached <> 0);
    local [rbda, _] = tr StripBondExtra detached_bonds [indexof [rbaa, baa]];

    local ibda = indexof [rbda, atoms];
    local ibaa = indexof [rbaa, atoms];

    return twrite ['&FRAGMENT\n{}\n{}\n{}\n{}\n{}\n/',
        AbinitMpFragmentFormat app length fragments,
        AbinitMpFragmentFormat (app add aFCharge fragments + app length detached - app length attached),
        AbinitMpFragmentFormat (app length attached),
        tok_cat droplast cat tr [app AbinitMpFragmentFormat atom_indices, '\n'],
        tok_cat droplast cat tr [apt AbinitMpFragmentFormat [ibda, ibaa], '\n']
    ];
endfunction


function fmoe_fragmentation opts
    opts = tagcat [opts, [
        template: 'templates\\sample.ajf',
        renderer: 'bin\\fill_template.win64.exe',
        moe: 'tests\\test.moe',
        fbase: 'test',
        pdb: 'tests\\temp\\test.pdb',
        ajf: 'tests\\temp\\test.ajf',
        basis_set: '6-31g*',
        bda_id: 0,
        baa_id: 0
    ]];
    print opts;
    Open opts.moe;
    local detached_bonds = dvar_open [];
    local fragments = dvar_open [];
    local chains = Chains [];
    AutoSplitBonds [detached_bonds, chains];
    UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
    local pdb_path = fopenw opts.pdb;
    local w_atoms = fwrite_abinitmp_pdb [pdb_path, chains];
    fclose pdb_path;
    // For manual fragmentation test.
    // pretend to cut by BondPicker [].
    if (opts.bda_id and opts.baa_id) then 
        local bda = Atoms [] | aNumber Atoms [] == opts.bda_id;
        local baa = Atoms [] | aNumber Atoms [] == opts.baa_id;
        AddSplitBond [detached_bonds, [bda, baa]];
        UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
    endif
    RenderTemplate [
        BASENAME: opts.fbase,
        TOTAL_CHARGE: totok add cat aFCharge cAtoms chains,
        NUM_FRAGS: totok length *fragments,
        BASIS_SET: opts.basis_set,
        ABINITMP_FRAGMENT: FormatAbinitMpFragment [w_atoms, *fragments, *detached_bonds],
        renderer: opts.renderer,
        TEMPLATE_PATH: ffullname opts.template,
        OUTPUT_PATH: ffullname opts.ajf
    ];
endfunction


global function FMOEFragmentationGUI opts
    opts = tagcat [opts, [
        test: '', 
        merge: 0,
        merge_list: []
    ]];

    local quit = dvar_open [];
    dvar_lock quit;

    local wkey = WindowCreate GetFragmentationPanel opts;
    WindowShow wkey;

    // fmoe_templates is a globaal variable.
    if fmoe_templates == '' then
        fmoe_templates = fcat [GetBasedir[], 'templates'];
    endif
    local templates = GetTemplates fmoe_templates;

    local detached_bonds = dvar_open [];
    local fragments = dvar_open [];

    local chains = Chains[];

    AutoSplitBonds [detached_bonds, chains];  // slow
    UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];  // slow
    // TODO: remove the hard coding, i.e. '6-31g'.
    opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
    RefreshWindow [wkey, '6-31g*', *detached_bonds, *fragments, opts];

    // TODO: rename select_template more acculately.
    WindowSetAttr [wkey, [select_template: [text: templates]]];
    local [default_basisset, aliases] = GetProgramBasisSets fext (WindowGetData [wkey, ['select_template']]).select_template;
    WindowSetAttr [wkey, [select_basisset: [text: first untag aliases]]];

    if not (default_basisset === []) then
        WindowSetData [wkey, [select_basisset: default_basisset]];
    endif

    // ?
    task_call [#CleanupMain, [quit, wkey, detached_bonds], [master: 'none', creator: 'detach']];
    // TODO: more acculate naming
    task_call [#Sentinel, [wkey, detached_bonds, fragments], [master: 'parent', creator: 'detach']];

    loop
        local [values, trigger] = WindowWait wkey;

        if trigger === 'auto' then
            RemoveAutoBonds detached_bonds;
            AutoSplitBonds [detached_bonds, chains];
            // TODO: neccessary for more precise treatment of a reference variable(fragments).
            // TODO: chains should be reset.
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            // TODO: second varibles should be more understandable. 
            RefreshWindow [wkey, tagget [aliases, values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif

        if trigger === 'reset' then
            RemoveAllBonds detached_bonds;
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases, values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'remove_bond' then
            // naming? Indices? not Pointer or Key?
            RemoveBondsByIndices [detached_bonds, first values.detached_bond_list];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases, values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'refresh' then
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases, values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'add_bond' then
            local [bda, baa] = BondPicker [];
            if not (bda and baa) then
                continue;
            endif
            AddSplitBond [detached_bonds, [bda, baa]];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases,  values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'select_basisset' then
            // ?
            RefreshWindow [wkey, tagget [aliases, values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'detached_bond_list' then
            aSetSelected [Atoms [], 0];
            local selected_detached_atoms = cat StripBondExtra (*detached_bonds)[first values.detached_bond_list];
            aSetSelected [selected_detached_atoms, 1];
            WindowSetData [wkey, [
                fragment_list: (igen length *fragments) | app length AssignAtomsToFragments [selected_detached_atoms, *fragments]
            ]];
            continue;
        endif
        
        if trigger === 'fragment_list' then
            aSetSelected [Atoms[], 0];
            local selected_fragmennt_atoms = cat (*fragments)[first values.fragment_list];
            aSetSelected [selected_fragmennt_atoms, 1];
            WindowSetData [wkey, [
                detached_bond_list: (igen length *detached_bonds) | app orE app orE apt eqE [[[selected_fragmennt_atoms]], StripBondExtra *detached_bonds]
            ]];
            continue;
        endif

        if trigger === 'merge_list' then
            aSetSelected [Atoms[], 0];
            print first values.merge_list;
            print opts.merge_list;
            aSetSelected [cat (*fragments)[third tr values.merge_list], 1];
            continue;
        endif

        if trigger === 'merged_fragment_list' then
            aSetSelected [Atoms[], 0];
            aSetSelected [cat opts.merged_fragments[first values.merged_fragment_list], 1];
            continue;
        endif

        if trigger === 'add_merge' then
            opts.merge_list = cat [opts.merge_list, [first values.fragment_list]];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases,  values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif

        if trigger === 'remove_merge' then
            local index = second values.merge_list;
            local mask = one igen length opts.merge_list;
            mask(index) = 0;
            opts.merge_list = opts.merge_list | mask;
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases,  values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif
        
        if trigger === 'reset_merge' then
            opts.merge_list = [];
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            RefreshWindow [wkey, tagget [aliases,  values.select_basisset], *detached_bonds, *fragments, opts];
            continue;
        endif

        if trigger === 'fmoe_fragmentation' then
            UpdateFragments [fragments, cat cAtoms chains, *detached_bonds];
            opts.merged_fragments = mergeFragments [*fragments, opts.merge_list];
            // Check the selected template is an ajf file.
            if not (fext values.select_template === 'ajf') then
                Warning twrite ['unknown template extension: {}', fext values.select_template];
                continue;
            endif

            // Check Atom type for abinitmp execution.
            local [[ok, _], state] = task_call [#AlertAtomDialog, cat cAtoms chains, [master: 'parent']];
            if not (state === '' and ok) then
                continue;
            endif 

            // Set output basename.
            local path_prefix = AbinitMpFilePrompt [];
            if path_prefix === [] then
                continue;
            endif

            // Write PDB file.
            local pdb_file = fopenw tok_cat [path_prefix, '.pdb'];
            local w_atoms = fwrite_abinitmp_pdb [pdb_file, chains];
            fclose pdb_file;
            

            local envTemplate = [
                BASENAME: ftail path_prefix,
                TOTAL_CHARGE: totok add cat aFCharge cAtoms chains,
                BASIS_SET: values.select_basisset
            ];
            
            if opts.merge then
                envTemplate = tagcat [envTemplate, [
                    NUM_FRAGS: totok length opts.merged_fragments,
                    ABINITMP_FRAGMENT: FormatAbinitMpFragment [w_atoms, opts.merged_fragments, *detached_bonds]
                ]];
            else
                envTemplate = tagcat [envTemplate, [
                    NUM_FRAGS: totok length *fragments,
                    ABINITMP_FRAGMENT: FormatAbinitMpFragment [w_atoms, *fragments, *detached_bonds]
                ]];
            endif
            
            // Render ajf file.
            RenderTemplate tagcat [envTemplate, [
                TEMPLATE_PATH: ffullname fcat [fmoe_templates, values.select_template],
                OUTPUT_PATH: ffullname tok_cat [path_prefix, '.ajf']]
            ];

            // Render sh file.
            if not ((WindowGetData [wkey, ['gen_job']]).gen_job) then
                continue;
            endif
            RenderTemplate tagcat [envTemplate, [
                TEMPLATE_PATH: ffullname fcat [fmoe_templates, tok_cat [fbase values.select_template, '.sh']],
                OUTPUT_PATH: ffullname tok_cat [path_prefix, '.sh']]
            ];
            continue;
        endif
    endloop
    WindowDestroy wkey;
endfunction


local function main opts
    if opts.test == 'fragmentation' then
        fmoe_fragmentation opts; 
    endif
    if opts.test == 'fragmentation_gui' then
        Open opts.moe;
        FMOEFragmentationGUI opts;
    endif
    if opts.test == 'merge' then
        print formatMergeList opts.merge_list;
    endif
    if opts.test == 'merge_fragments' then
        local merge_list = [[1,2,3], [4,5,6]];
        print formatMergeList opts.merge_list;
    endif
endfunction
