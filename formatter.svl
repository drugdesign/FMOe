#svl

function AssignAtomsToFragments;
function GetNumberOfFunctions;
function StripBondExtra;

function FormatDetachedBonds bonds
    // :bonds:
    // return: 
    // TODO: move to model
    local bda = first tr bonds;
    local baa = second tr bonds;
    local types = third tr bonds;
    return apt twrite [
        '{}\t{}\t{}{} {}\t{}{} {}',
        igen length bonds, types,
        rName aResidue bda, rUID aResidue bda, aName bda,
        rName aResidue baa, rUID aResidue baa, aName baa
    ];
endfunction

function FormatAtomName [atom]
    if tok_length aElement atom == 1 then
        return tok_cat [' ', aName atom];
    else
        return aName atom;
    endif
endfunction

function FormatMergeList merge_list
    // :bonds:
    // return: 
    // TODO: check duplicate
    local data = [];
    local i, j;
    for i = 1, length merge_list loop
        for j = 1, length merge_list(i) loop
            data = cat [data, [[i, merge_list(i)(j)]]];
        endloop
    endloop
    return apt twrite [
        '{}\t{}\t{}',
        igen length first tr data,
        first tr data,
        second tr data
    ];
endfunction

local function AbinitMpFragmentFormat l
    local result = [];
    while length l >= 10 loop
        result = append [result, tok_cat apt twrite ['{n:8}', keep [l, 10]]];
        l = drop [l, 10];
    endloop
    if length l <> 0 then
        result = append [result, tok_cat apt twrite ['{n:8}', l]];
    endif
    return tok_cat droplast cat tr [result, '\n'];
endfunction


function FormatAbinitMpFragment [atoms, fragments, detached_bonds]
    // need to refactor
    local [bda, baa] = tr StripBondExtra detached_bonds;
    local detached = AssignAtomsToFragments [bda, fragments];
    local attached = AssignAtomsToFragments [baa, fragments];
    local atom_indices = app sort apt indexof [fragments, [atoms]];

    local rbaa = cat attached | cat (attached <> 0);
    local [rbda, _] = StripBondExtra detached_bonds [indexof [rbaa, baa]];

    local ibda = indexof [rbda, atoms];
    local ibaa = indexof [rbaa, atoms];

    return twrite ['&FRAGMENT\n{}\n{}\n{}\n{}\n{}\n/',
        AbinitMpFragmentFormat app length fragments,
        AbinitMpFragmentFormat (app add aFCharge fragments + app length detached - app length attached),
        AbinitMpFragmentFormat (app length attached),
        tok_cat droplast cat tr [app AbinitMpFragmentFormat atom_indices, '\n'],
        tok_cat droplast cat tr [apt AbinitMpFragmentFormat [ibda, ibaa], '\n']
    ];
endfunction


local function Common t
    // ?
    if t === [] then
        return [];
    endif
    if isflat t then
        t = [t];
    endif
    local cand = app uniq t;
    local freq = apt freq [cand, t];
    return apt get [cand, app x_max freq];
endfunction


function FormatFragments [basisset, fragments, detached, attached]
    // :basisset: 
    // :fragments: List[List[atom]]
    // :detached: List[atom]
    // :attached: List[atom]
    local res = Common rName aResidue fragments;
    local resi = totok Common rUID aResidue fragments;
    local nD = app length detached;
    local nA = app length attached;

    return apt twrite [
        '{}\t{}\t{}\t{}\t{}\t{}\t{}',
        igen length fragments, apt tok_cat [res, resi], app length fragments,
        GetNumberOfFunctions [basisset, apt cat [fragments, attached]],
        nD, nA, app add aFCharge fragments + nD - nA
    ];
endfunction